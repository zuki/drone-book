# スレッド

Drone OSのスレッドはハードウェア割り込みに相当します。割り込みコントローラにより
独立に管理される一連のファイバです。スレッドは必要に応じて作成することはできません。
特定のプロジェクト用にあらかじめ定義しておく必要があります。そうすれば、任意の数の
ファイバを特定のスレッドに動的にアタッチすることができます。

スレッドは`src/thr.rs`で`thr!`マクロと`thr::vtable!`マクロを使って定義する
必要があります。

```rust
thr::vtable! {
    use Thr;

    /// ベクタテーブル型.
    pub struct Vtable;

    /// 明示的なベクタテーブルハンドラ.
    pub struct Handlers;

    /// スレッドトークンのセット.
    pub struct Thrs;

    /// スレッドデータの配列.
    static THREADS;

    // --- 割り当て済みのスレッド ---

    /// 全フォールトクラス.
    pub HARD_FAULT;
    /// マイタスクのためのスレッド.
    pub 10: MY_THREAD;
}

thr! {
    use THREADS;

    /// スレッドデータ.
    pub struct Thr {}

    /// スレッドローカルなストレージ.
    pub struct ThrLocal {}
}
```

マクロは`Thr`オブジェクトの静的配列である`THREADS`を定義します。この例では、
配列には3つの要素が含まれています。`HARD_FAULT`と`MY_THREAD`、そして暗黙の
`RESET`スレッドデータです。`Thrs`構造体もここで作成されますが、これは
ゼロサイズ型のトークンセットであり、これを介してスレッドを操作することができます。
このトークンセットは一度だけインスタンス化することができ、通常はルートタスクの
一番はじめに行います。

```rust
/// ルートタスクハンドラ.
#[inline(never)]
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let thr = thr::init(thr_init);

    // ... 他のハンドラ ...
}
```

ここで`thr`変数には、定義されているすべてのスレッドのトークンが含まれています。
`Thr`定義にフィールドを追加した場合は、`thr.my_thread.to_thr()`を通して
アクセスできます。`ThrLocal`も`Thr`内に格納されますが、独立した関数である
`thr::local()`を通じてのみアクセスできます。

スレッドは、暗黙的な`core::task::Waker`や明示的な`thr.my_thread.trigger()`
を使用してプログラムから、あるいは直接ハードウェアペリフェラルから呼び出すことが
できます。トリガされたスレッドの優先度が現在アクティブなスレッドよりも高い場合、
アクティブなスレッドはプリエンプションされます。スレッドの優先度が低い場合は、
優先度の高いすべてのスレッドの後に実行されます。優先度は
`thr.my_thread.set_priority(...)`メソッドを使いその場で変更できます。

## ファイバチェイン

スレッドが所有する主たるものはファイバチェインです。ファイバチェーンは基本的には
ファイバのリンクドリストです。ファイバは`thr.my_thread.add_fib(...)`や
それに基づく他のメソッドを使ってスレッドチェーンに動的に追加することができます。
`add_fib`メソッドはアトミックなので他のスレッドからあるスレッドにファイバを
追加することができます。

スレッドがトリガされると、そのファイバチェーン内のファイバをLIFO順に1つずつ
実行します。言い換えると、最も新しく追加されたファイバが最初に実行されます。
ファイバは`fib::Yielded`を返すことができます。これは、ファイバが一時停止され
完了していないことを意味します。この場合、スレッドはそのファイバを後で実行できる
ように保持し、チェーンの次のファイバを実行します。ファイバは`fib::Complete`を
返すこともできます。この場合、スレッドはそのファイバをチェーンから削除し、
その`drop`デストラクタを実行します。そして、チェーンの次のファイバを実行します。

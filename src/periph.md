# ペリフェラルマッピング

ペリフェラルのマッピングには主に2つの目的があります: 使いやすいようにメモリマップド
レジスタと個々のレジスタフィールドを1つのブロックにまとめることと、同タイプの複数の
ペリフェラル（たとえば、SPI1、SPI2、SPI3）用の一つの汎用ブロックを作成することです。

レジスタマッピングは、SVDファイルからほぼ自動的に生成することができます（品質が悪く、
手で修正しなければならないことも多いです）が、Droneでは強力なプロシージャマクロの
助けを借ることで、サポートされているターゲットごとにペリフェラルマッピングを手作業で
定義しています。このため、すべてのターゲットで利用可能なすべてのペリフェラルをマッピング
することはできませんが、可能な限り簡単にマッピングできるように努力しています。そのため、
ユーザー自身が不足しているペリフェラルのマッピングを行い、それをDrone OSにフィード
バックすることも可能です。ペリフェラルマッピングの作成方法については、
`drone_core::periph`のドキュメントを参照してください。

ペリフェラルマッピングは必要なすべてのレジスタトークンを取得するためのマクロを
定義します。以下の例では、`periph_gpio_c!`と`periph_sys_tick!`がそのような
マクロです。

```rust
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);
    beacon(gpio_c, sys_tick)
}
```

`gpio_c`と`sys_tick`オブジェクトはゼロサイズであり、これらのコードはランタイム
コストを発生させません。これらのオブジェクトは、対応するペリフェラルに関連する
すべてのレジスタとフィールドトークンを保持します。1つのペリフェラルに対して2つの
インスタンスを作成することはできません。最初のマクロを呼び出した後、`reg`オブジェクトは
一部がムーブされた状態になるからです。

`beacon`関数は以下のように定義できます。

```rust
fn beacon(
    gpio_c: GpioPortPeriph<GpioC>,
    sys_tick: SysTickPeriph,
) {
    // ...
}
```

引数`gpio_c` の型は汎用構造体であることに注意してください。同じインタフェースを
持つ可能性のある多くのペリフェラル（`GpioA`、`GpioB`、`GpioC`など）があるためです。
一方、`sys_tick`型は汎用ではありません。なぜなら、チップにはSysTickペリフェラルが
一つしかないからです。ビーコン機能をGPIOポートに対する汎用的なものになるように定義する
ことは簡単です。

```rust
fn beacon<GpioPort: GpioPortMap>(
    gpio_c: GpioPortPeriph<GpioPort>,
    sys_tick: SysTickPeriph,
) {
    // ...
}
```

これは、ドライバを定義するための推奨かつ非常に便利な方法です。SDカードドライバを
たとえばSPI3でしか使用できないようにハードコーディングすることはしたくはないです。
もう一つのアプローチとしては、ドライバコード全体をマクロでラップして、SPI1, SPI2,
SPI3を引数として呼び出す方法があります。しかし、これはあまりクリーンでも慣用的な
ものでもないと思います。

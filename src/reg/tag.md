# メモリマップドレジスタトークンタグ

レジスタトークンが持つ正確な型が何であるかを詳しく見てみましょう。

```rust
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let rcc_cr: reg::rcc::Cr<Srt> = reg.rcc_cr;
}
```

レジスタトークンタグは汎用パラメータであるレジスタタグを一つ持っています。
レジスタタグは3種類あります。

* Urt (**U**nsynchronized **r**egister **t**ag: 非同期レジスタタグ)
* Srt (**S**ynchronized **r**egister **t**ag: 同期レジスタタグ)
* Crt (**C**opyable **r**egister **t**ag: コピー可能なレジスタタグ)

タグはread-modify-write操作におけるデータ競合を排除し、トークンのムーブ
セマンティクスを制御するために非常に重要です。

![Register Token Tags](../assets/reg-tags.svg)

ここで、`RegOwned`は`Copy`トレイトを実装して*いない*種類のタグであり、
`RegAtomic`はすべてのread-modify-write操作をアトミックにします。

アトミックタグを持たないレジスタトークンやフィールドトークン(`Urt`)に対する操作は、
排他的(`&mut`)借用を必要とします。一方、アトミックなトークン(`Srt`、`Crt`)は
共有(`&`)借用（参照）を必要とします。これにより、Rustのコンパイル時のチェックを利用して
データ競合の可能性を排除します。`Urt`タグ付きトークンはより効果的だが非アトミックな
プロセッサ命令を使用しますが、同時に使用することはできません。データ競合の可能性の
あるプログラムはコンパイラによって拒絶され、ランタイム時の追加チェックはありません。

レジスタトークン全体において、アトミック性に関して影響を受ける操作は`modify`メソッド
だけです。しかし、フィールドトークンについては、アトミックタグを使用すると、すべての
書き込み操作に追加コストがかかります。なぜなら、フィールドトークンが異なるスレッド間で
共有される可能性があるからです。

トークンのもう一つの属性は（`RegOwned`トレイトにより表現される）アフィニティです。
アフィン型はコピーもクローンもできず、Rustのムーブセマンティクスを使用します。
トークンがアフィンタグ(`Urt`, `Srt`)を持つ場合、この特定のレジスタやフィールドには
1つのトークンしか存在しないことが保証されます。しかし、そのようなトークンでも複数の
共有借用を持つ可能性があります。非アフィン(`Crt`)トークンは`Copy`トレイトを実装
しているので自由にコピーすることができます。トークンはゼロサイズなので、トークンの
コピーもゼロコストです。一方、コピー可能なトークンは常にアトミックです。

トークンのタグを別のタグに切り替えるために、すべてのレジスタトークンとレジスタ
フィールドトークンは両者とも次の3つのメソッドを提供しています。

* into_unsync() - 非同期トークンに変換する
* into_sync() - 同期トークンに変換する
* into_copy() - コピー可能なトークンに変換する

これらのメソッドは，トークンを値で受け取り，同じ型の新しいトークンを返しますが，
異なるタグを持ちます。すべての変換が可能というわけではありません。たとえば、
トークンが既に`Crt`である場合、`Srt`や`Urt`に戻る方法はありません。なぜなら、
`Crt`トークンの可能性のあるすべてのコピーが削除されることを保証できないからです。
詳細については`drone_core::reg`のドキュメントを参照してください。推測されて
いると思いますが、これらの変換メソッドは完全にゼロコストです。

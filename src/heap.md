# 動的メモリ

Rustの型システムの能力を最大限に引き出すために、Drone OS はグローバルアロケータを
提供しています。これは逆説的に思えるかもしれませんが、ランタイムダイナミズムの追加は
コンパイル時のチェックに役立ちます。libstdの`thread::spawn`関数のシグネチャを
考えてみます。

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T> where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static;
```

これは、`std`アプリケーションで新規OSスレッドをスポーンするには、実行時に
`thread::spawn`関数を呼び出し、`F`型のクロージャを渡す必要があることを意味
します。ここで興味深いのは、`F: Send + 'static`境界です。これは、クロージャに
よって捕捉されたデータがまた`Send`かつ`'static`であることを保証します。
`'static`は、プログラム全体よりも狭いスコープを持つ参照を拒絶します。また、
`Send`はスレッドセーフではない型を拒絶します。ここでの良い点は、これらの
プロパティがすべてコンパイル時にチェックされることです。当然のことながら、
Drone OSの相当する関数も同様のシグネチャを持っています。

組み込みシステム用のアロケータは、以下の条件を満たす必要があります。

1. 決定的。リアルタイムシステムでは、割り当て、割り当て解除、再割り当ての
   操作が予測可能なタイミングを持っていることが重要です。

2. 小さなコードサイズ。たとえば、jemallocは何百キロバイトものバイナリサイズを
   追加できますが、サポートされているMCUの中には64KBやそれ以下のフラッシュ
   メモリしかもっていないものがあります。

Drone OSには、上記の条件を満たすシンプルで予測可能なアロケータが同梱されています。
これは、ヒープメモリ領域全体を多くの固定サイズのメモリプールに分割します。

![Memory Pools](../assets/heap-pools.svg)

このプールはコンパイル時に`Drone.toml`で設定されます。たとえば、次のように。

```toml
[heap]
size = "10K"
pools = [
    { block = "4", capacity = 118 },
    { block = "8", capacity = 148 },
    { block = "20", capacity = 82 },
    { block = "56", capacity = 34 },
    { block = "116", capacity = 16 },
    { block = "208", capacity = 8 },
    { block = "336", capacity = 3 },
    { block = "512", capacity = 1 },
]
```

この結果、Droneアロケータは全操作を一定時間かつ全くアトミックに実現しています。
しかし、このアプローチの欠点は、メモリを効率的に使用するには、各アプリケーション
ごとにプールを調整する必要があることです。Droneはそれを可能な限り簡単に行うための
ツールを提供しています。それについては次の章で扱います。

グローバルアロケータを提供することで、DroneアプリケーションはRustの`core`
クレートだけでなく、`alloc`クレートも使用することができます。これにより、
次のRustの型を使用することができます: `String`, `Vec`, `Box`, `Rc`, `Arc`
などです。

# テスト

組み込みシステムのテストは、標準的なアプリケーションのテストよりも難しいものです。
少なくとも2つのハードウェアプラットフォーム、1つはコンパイラを実行するシステムで、
もう一つはターゲットシステム、を使うからです。開発マシン上でのテストは非常に簡単ですが、
ハードウェア固有のコードのテストはできません。逆に、ターゲットシステム上で直接テスト
することははるかに難しく、精巧なハードウェアのセットアップが必要です。

Drone OSは最初から開発マシン上でのテストをサポートしています。Droneクレートだけで
なく、`drone new`で生成されるすべてのプロジェクトは、`std`という名前の特別な機能を
持ちます。次のコマンドでテストレシピを実行すると


```shell
$ just test
```

プログラムは開発マシン（通常は `x86_64-unknown-linux-gnu`）をターゲットとして
コンパイルされ、デバイスターゲット（たとえば、`thumbv7m-none-eabi`）用には
コンパイルされません。そして、プログラムは`std`機能を有効にしてコンパイルされます。
これにより、標準的なRustのテストランナーを実行することができます。

このようにすべての標準的なRustのテストオプションを使用することができます。
インライン`#[text]`関数、`tests/`ディレクトリに置く個別テストファイル、
 (`compile_fail`テストを含む) ドキュメントテストなどです。また、テストコードは
`std`クレートにアクセスできます。

ただし、通常、テスト時とリリースコードではポインタのサイズが異なることを覚えておく
必要があります。この種のテストは、アルゴリズムやビジネスロジックのテストに適しています。
ハードウェアに特化したコードは、コンパイルすらできないことがよくあります。このためには、`drone-cortexm`から採った以下のスニペットのように、条件付きコンパイルを使うべきです。

```rust
fn wait_for_int() {
    #[cfg(feature = "std")]
    return unimplemented!();
    unsafe { asm!("wfi" :::: "volatile") };
}
```

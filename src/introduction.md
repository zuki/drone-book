# 序章

DroneはRustでリアルタイムアプリケーションを書くための組み込みオペレーティングシステムです。現代的な開発アプローチをパフォーマンスに妥協することなく組み込みプログラミングの世界に持ち込むことを目的としています。

## サポートされているハードウェア

Droneコアは当初からプラットフォームには依存していません。しかし、現在はARM® Cortex®-M3/M4だけがサポートされています。

Droneは、`drone bmp`というコマンドの形で[Black Magic Probe](http://black-magic.org/)を特別にサポートしています。しかし、他のデバッグプローブの使用を制限するものではありません。

## 設計原理

- *最初からエネルギー効率の良さ*。Droneは割り込み駆動の実行モデルを奨励します。

- *ハードリアルタイム*。Droneは、クリティカルセクションの使用ではなくアトミックオペレーションに依存します。

- *厳密な優先順位を持つ完全なプリエンプティブマルチタスク*。優先度の高いタスクのレイテンシが最小になるよう優先されます。

- *高度な並行処理*。Droneのマルチタスクは非常に安価であり、Rustにより安全性も保証されます。

- *メッセージパッシングの並行処理*。Droneは同期処理プリミティブを提供します。

- *デフォルトではシングルスタック*。Droneの並行処理プリミティブは、基本的にはスタックレスのステートマシンです。しかし、*スタックフルなタスクもサポートされています*。

- *ダイナミックメモリが可能*。Droneは、決定論的でコード効率の良い状態を維持しながらも、可能文字列やベクタのような便利なデータ構造を使用できます。

## 何故、Droneを使うのか？

- async/awaitがデフォルト。Droneは、ネイティブのasync/await構文を使用し、`Futures`を
  実行するために必要なすべてのランタイムを提供します。

- `unsafe`コードが不要。Droneコアは`unsafe`コードに依存せざるを得ないという事実はありますが、
  Droneアプリケーションは、Droneが提供する安全な抽象化に完全に依存することができます。

- 現代的なツール。`cargo`パッケージマネージャや`rutfmt`コードフォーマッタ、`clippy`コード
  リンタなどの標準的なRustツールとは別に、Droneは`drone`コマンドラインユーティリティを提供
  しています。これにより、ハードウェア用の新規Droneプロジェクトの生成やデバッグプローブの管理を
  することができます。

- 一次スタックはMMU/MPUの存在に関わらずスタックオーバーフローから保護。ただし、二次スタック
  を使用するタスクは安全性の確保のためにMMU/MPUを必要とします。

- デバッグ用通信チャンネル。Rustの`print!`や`eprint!`、これと同等なマクロが、Cortex-Mの
  SWOのチャネル0とチャネル1にマップされています。デバッグプローブが接続されていない場合、
  デバッグメッセージはオーバーヘッドを発生させません。

- `Drone.toml`設定ファイル。リンカスクリプトを手で書く手間が省けます。

- メモリマップドレジスタのための豊富で安全なゼロコスト抽象化。Droneはベンダー提供のSVD
  ファイルからレジスタバインディングを自動的に生成します。また、類似したペリフェラルに対して
  汎用的なコードを書く方法も提供します。

## Droneは何をしないか

- Droneは動的アプリケーションの読み込みには対応しません。ライブラリOSであり、アプリケーションに
  静的にリンクされます。

- Droneはタイムスライシングを実装しません。実行モデルが異なります。ただし、将来的には
  オプションのタイムスライシングが追加されるかもしれません。
